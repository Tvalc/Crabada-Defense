<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SNIB Tower Defense Game</title>
  <style>
    body { background:#222; color:#fff; font-family:sans-serif; text-align:center; }
    canvas { background:#333; margin:20px auto; display:block; border-radius:10px; }
    #ui { margin-bottom:10px; }
    button { font-size:18px; margin:0 8px; }
    #message { color:#ff7; font-weight:bold; }
  </style>
</head>
<body>
  <h2>SNIB Tower Defense</h2>
  <div id="ui">
    <span id="money">Money: $100</span> &nbsp;
    <span id="lives">Lives: 10</span> &nbsp;
    <span id="wave">Wave: 1</span> &nbsp;
    <button id="startBtn">Start Wave</button>
    <span id="message"></span>
  </div>
  <canvas id="game" width="640" height="480"></canvas>
  <script>
const TILE_SIZE = 40;
const GRID_W = 16, GRID_H = 12;
const CANVAS_W = TILE_SIZE * GRID_W, CANVAS_H = TILE_SIZE * GRID_H;

const PATH = [
  [0,5],[1,5],[2,5],[3,5],[4,5],
  [4,6],[5,6],[6,6],[7,6],
  [7,5],[8,5],[9,5],[10,5],
  [10,4],[11,4],[12,4],[13,4],[14,4],[15,4]
];

const ENEMY_HP = 30;
const ENEMY_REWARD = 10;
const TOWER_COST = 40;
const TOWER_RANGE = 100;
const TOWER_FIRE_RATE = 60; // frames per shot (~1 sec @ 60fps)
const BULLET_SPEED = 6;
const BULLET_DAMAGE = 15;

let canvas = document.getElementById('game');
let ctx = canvas.getContext('2d');

// Game State
let towers = [];
let enemies = [];
let bullets = [];
let money = 100;
let lives = 10;
let wave = 1;
let waveInProgress = false;
let spawnIndex = 0;
let spawnTimer = 0;
let messageTimeout = null;

// UI Elements
const moneySpan = document.getElementById('money');
const livesSpan = document.getElementById('lives');
const waveSpan = document.getElementById('wave');
const startBtn = document.getElementById('startBtn');
const messageSpan = document.getElementById('message');

// Helper: Grid <-> px coordinate conversions
function toWorld(x, y) { return [x*TILE_SIZE+TILE_SIZE/2, y*TILE_SIZE+TILE_SIZE/2]; }
function fromWorld(px, py) { return [Math.floor(px/TILE_SIZE), Math.floor(py/TILE_SIZE)]; }

// Helper: Check if grid cell is on the path
function isPathCell(x,y) {
  return PATH.some(p => p[0]===x && p[1]===y);
}

// Show a temporary message
function showMessage(msg, ms=1200) {
  messageSpan.textContent = msg;
  if (messageTimeout) clearTimeout(messageTimeout);
  messageTimeout = setTimeout(()=>{messageSpan.textContent=''}, ms);
}

// Game Loop
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Update Game State
function update() {
  // Wave/Enemy Spawning
  if (waveInProgress && spawnIndex < wave*5) {
    if (--spawnTimer <= 0) {
      spawnEnemy();
      spawnIndex++;
      spawnTimer = 40; // spawn interval frames
    }
  }

  // Update Enemies
  for (let e of enemies) {
    if (!e.dead) {
      moveEnemy(e);
      if (e.pathIdx >= PATH.length-1 && !e.reachedEnd) {
        // Enemy reached end
        e.reachedEnd = true;
        e.dead = true;
        lives--;
        showMessage("An enemy got through!");
        if (lives <=0 ) gameOver();
      }
    }
  }
  // Remove dead enemies (after offscreen)
  enemies = enemies.filter(e => !e.dead || (e.x>=0 && e.x<CANVAS_W && e.y>=0 && e.y<CANVAS_H));

  // Update Towers (fire logic!)
  for (let t of towers) {
    t.cooldown--;
    // Find closest enemy in range
    let target=null, minDist=Infinity;
    for (let e of enemies) {
      if (e.dead || e.reachedEnd) continue;
      let dx=e.x-t.x, dy=e.y-t.y, dist=Math.hypot(dx,dy);
      if (dist<=t.range && dist<minDist) {
        minDist=dist; target=e;
      }
    }
    // Fire if ready and target found
    if (target && t.cooldown<=0) {
      fireBullet(t,target);
      t.cooldown=t.fireRate;
    }
  }

  // Update Bullets
  for (let b of bullets) {
    let dx=b.target.x-b.x, dy=b.target.y-b.y;
    let dist=Math.hypot(dx,dy);
    if (!b.target.dead && dist<=b.speed) {
      // Hit!
      b.target.hp -= b.damage;
      b.hit=true;
      if (b.target.hp<=0 && !b.target.dead) {
        b.target.dead=true; money+=ENEMY_REWARD;
        showMessage("+$"+ENEMY_REWARD);
      }
    } else if (!b.target.dead) {
      b.x += b.speed*dx/dist;
      b.y += b.speed*dy/dist;
    } else {
      b.hit=true;
    }
  }
  // Remove bullets that have hit or lost their target
  bullets = bullets.filter(b => !b.hit);

  // End wave if all spawned and all enemies dead
  if (waveInProgress && spawnIndex>=wave*5 && enemies.every(e=>e.dead)) {
    waveInProgress=false;
    wave++;
    waveSpan.textContent="Wave: "+wave;
    showMessage("Wave "+(wave-1)+" cleared!",1500);
    startBtn.disabled=false;
  }

  // Update UI
  moneySpan.textContent="Money: $"+money;
  livesSpan.textContent="Lives: "+lives;
}

// Enemy Spawn
function spawnEnemy() {
  let [gx,gy] = PATH[0];
  let [x,y] = toWorld(gx,gy);
  enemies.push({
    x:x, y:y,
    hp: ENEMY_HP + (wave-1)*10,
    pathIdx:0,
    dead:false,
    reachedEnd:false
  });
}

// Move along the path
function moveEnemy(e) {
  if (e.pathIdx>=PATH.length-1) return;
  let [nx,ny]=PATH[e.pathIdx+1];
  let [tx,ty]=toWorld(nx,ny);
  let dx=tx-e.x, dy=ty-e.y, dist=Math.hypot(dx,dy);
  let speed=1.1 + Math.min(wave/3,2); // speed up per wave
  if (dist<=speed) {
    e.x=tx; e.y=ty; e.pathIdx++;
  } else {
    e.x += speed*dx/dist;
    e.y += speed*dy/dist;
  }
}

// Tower Placement by mouse click
canvas.addEventListener('click', function(evt){
  if (waveInProgress) return showMessage("Can't build during wave!");
  const rect=canvas.getBoundingClientRect();
  const mx=evt.clientX-rect.left, my=evt.clientY-rect.top;
  const [gx,gy]=fromWorld(mx,my);
  
  // Bounds check
  if (gx<0||gx>=GRID_W||gy<0||gy>=GRID_H) return;

  // No building on path!
  if (isPathCell(gx,gy)) return showMessage("Can't build on path!");
  
  // No stacking towers!
  if (towers.some(t=>t.gx===gx&&t.gy===gy)) return showMessage("Tower already here!");

  if (money<TOWER_COST)
    return showMessage("Not enough money!");

  let [wx,wy]=toWorld(gx,gy);
  
  towers.push({
    gx:gx, gy:gy,
    x:wx,y:wy,
    range:TOWER_RANGE,
    fireRate:TOWER_FIRE_RATE,
    cooldown:0
  });
  
  money-=TOWER_COST;
});

// Firing Bullets!
function fireBullet(tower,target) {
  bullets.push({
    x:tower.x,
    y:tower.y,
    target:target,
    damage:BULLET_DAMAGE,
    speed:BULLET_SPEED,
    hit:false
  });
}

// Draw Everything
function draw() {
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

  // Draw grid and path
  for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) {
    ctx.strokeStyle="#444";
    ctx.lineWidth=1.3;
    ctx.strokeRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);

    if(isPathCell(x,y)) {
      ctx.fillStyle="#664";
      ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
    }
  }

  // Draw Path lines
  ctx.beginPath();
  ctx.strokeStyle="#ff8";
  ctx.lineWidth=4;
  for(let i=0;i<PATH.length;i++) {
    let [gx,gy]=PATH[i];
    let [wx,wy]=toWorld(gx,gy);
    ctx.lineTo(wx,wy);
    if(i==0) ctx.moveTo(wx,wy);
  }
  ctx.stroke();

  // Draw Towers
  for(let t of towers) {
    // Range circle
    ctx.beginPath();
    ctx.arc(t.x,t.y,t.range,0,2*Math.PI);
    ctx.strokeStyle="rgba(120,200,255,.12)";
    ctx.lineWidth=1.2;
    ctx.stroke();

    // Tower body
    ctx.beginPath();
    ctx.arc(t.x,t.y,TILE_SIZE/2.3,0,2*Math.PI);
    ctx.fillStyle="#38f";
    ctx.fill();
    ctx.strokeStyle="#fff";
    ctx.lineWidth=2.3;
    ctx.stroke();
    
    // Cannon tip (for fun)
    ctx.save();
      ctx.translate(t.x,t.y);
      // Show direction to closest enemy?
      let ang=0,target=null,minDist=9999;
      for(let e of enemies)
        if(!e.dead&&!e.reachedEnd){
          let d=Math.hypot(e.x-t.x,e.y-t.y);
          if(d<t.range && d<minDist){minDist=d;ang=Math.atan2(e.y-t.y,e.x-t.x);}
        }
      ctx.rotate(ang);
      ctx.fillStyle="#fff";
      ctx.fillRect(TILE_SIZE/6,-4,TILE_SIZE/1.9,8);
    ctx.restore();
    
  }

  // Draw Bullets
  for(let b of bullets){
    ctx.beginPath();
    ctx.arc(b.x,b.y,6,0,2*Math.PI);
    ctx.fillStyle="#ff3";
    ctx.fill();
    ctx.strokeStyle="#c80";
    ctx.lineWidth=2;
    ctx.stroke();
   }

   // Draw Enemies
   for(let e of enemies){
     if(e.dead && !e.reachedEnd){
       // death effect
       ctx.save();
       ctx.globalAlpha=.5+(Math.random()-.5)*.3;
       ctx.beginPath();
       ctx.arc(e.x,e.y,TILE_SIZE/2*(1+.25*Math.random()),0,2*Math.PI);
       ctx.fillStyle="#fa7";
       ctx.fill(); 
       ctx.restore();
       continue;
     }
     // Body
     ctx.beginPath();
     ctx.arc(e.x,e.y,TILE_SIZE/2.2,0,2*Math.PI);
     ctx.fillStyle="#d22";
     ctx.fill();

     // HP bar
     let hpw=TILE_SIZE*.8*(e.hp/(ENEMY_HP+(wave-1)*10));
     ctx.fillStyle="#2f4";
     ctx.fillRect(e.x-TILE_SIZE*.4,e.y-TILE_SIZE*.7,hpw,TILE_SIZE*.15);

     // Eye/cute details
     ctx.beginPath();
     ctx.arc(e.x-TILE_SIZE/9,e.y-TILE_SIZE/8,TILE_SIZE/12,0,2*Math.PI);
     ctx.arc(e.x+TILE_SIZE/9,e.y-TILE_SIZE/8,TILE_SIZE/12,0,2*Math.PI);
     ctx.fillStyle="#fff";
     ctx.fill();
   }
}

// Start wave button logic
startBtn.onclick=function(){
   if(waveInProgress)return;
   waveInProgress=true;
   spawnIndex=0; spawnTimer=20;
   startBtn.disabled=true;
};

// Game over logic
function gameOver() {
   showMessage("Game Over!",5000);
   waveInProgress=false;
   startBtn.disabled=true;
   setTimeout(()=>location.reload(),3000);
}

// Initial draw/UI sync and start loop!
moneySpan.textContent="Money: $"+money;
livesSpan.textContent="Lives: "+lives;
waveSpan.textContent="Wave: "+wave;

gameLoop();

</script>
</body>
</html>