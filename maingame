<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Strategy Tower Defense Game - Multiple Towers</title>
  <style>
    body { background: #222; color: #eee; font-family: sans-serif; }
    #ui {
      margin-bottom: 8px;
      padding: 12px;
      background: #171717;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
      user-select: none;
    }
    .tower-btn {
      border: none;
      border-radius: 5px;
      padding: 8px 18px;
      margin-right: 6px;
      font-weight: bold;
      cursor: pointer;
      outline: 2px solid transparent;
      transition: background .2s, outline .2s, filter .2s;
    }
    .tower-btn.selected {
      outline: 2px solid #fff55d;
      filter: brightness(1.2);
    }
    .tower-btn.unavailable {
      filter: grayscale(0.85) opacity(0.6);
      cursor: not-allowed;
    }
    #gameCanvas { background: #111; display:block; margin:auto; border-radius:8px;}
    #status {
      padding-left: 12px;
    }
  </style>
</head>
<body>
<div id="ui">
  <button id="tower-basic" class="tower-btn">Basic Tower ($50)</button>
  <button id="tower-sniper" class="tower-btn">Sniper ($100)</button>
  <span id="status"></span>
</div>
<canvas id="gameCanvas" width="640" height="448"></canvas>
<script>
// --- GAME CONFIG ---
const GRID_SIZE = 32;
const MAP_W = 20, MAP_H = 14;
const CANVAS_W = GRID_SIZE * MAP_W, CANVAS_H = GRID_SIZE * MAP_H;

// Path points (row,col)
const path = [
  [0,6],[1,6],[2,6],[3,6],[4,6],[5,6],[5,7],[5,8],[6,8],[7,8],[8,8],[9,8],[10,8],[10,9],[10,10],[11,10],[12,10],[13,10]
];

// Tower types
const TOWER_TYPES = [
  {
    name: "Basic",
    cost: 50,
    range: 90,
    damage: 18,
    cooldown: 600,
    color: "#34c759",
    radius: 13
  },
  {
    name: "Sniper",
    cost: 100,
    range: 170,
    damage: 40,
    cooldown: 1700,
    color: "#3787d4",
    radius: 14
  }
];

// Enemy config
const ENEMY_HP = 70, ENEMY_SPEED = 0.88 + Math.random()*0.2, ENEMY_REWARD = 13;

let gold = 150, lives = 10, wave = 1;
let selectedTowerTypeIdx = 0;

// --- UTILS ---
function dist(ax,ay,bx,by) { return Math.hypot(ax-bx,ay-by); }

// --- GAME STATE ---
let towers = [];
let enemies = [];
let bullets = [];
let placingMode = true;

// --- CANVAS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- UI SETUP ---
const statusEl = document.getElementById('status');
function updateUI() {
  statusEl.innerHTML =
    `<b>Gold:</b> $${gold} &nbsp; <b>Lives:</b> ${lives} &nbsp; <b>Wave:</b> ${wave}`;
}
function updateTowerButtons() {
  document.querySelectorAll('.tower-btn').forEach((btn,i)=>{
    btn.classList.toggle('selected', i===selectedTowerTypeIdx);
    btn.classList.toggle('unavailable', TOWER_TYPES[i].cost>gold);
    btn.disabled = (TOWER_TYPES[i].cost>gold);
  });
}
updateTowerButtons();

// Tower select buttons
document.getElementById('tower-basic').onclick = ()=>{selectedTowerTypeIdx=0;placingMode=true;updateTowerButtons();}
document.getElementById('tower-sniper').onclick= ()=>{selectedTowerTypeIdx=1;placingMode=true;updateTowerButtons();}

// --- MAP ---
function drawGrid(){
  ctx.save();
  ctx.strokeStyle='rgba(90,90,90,.4)';
  for(let x=0;x<=CANVAS_W;x+=GRID_SIZE){
    ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,CANVAS_H);ctx.stroke();
  }
  for(let y=0;y<=CANVAS_H;y+=GRID_SIZE){
    ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(CANVAS_W,y);ctx.stroke();
  }
  ctx.restore();
}
function isOnPath(row,col){
  return path.some(([r,c])=>r===row&&c===col);
}
function drawPath(){
  ctx.save();
  ctx.globalAlpha=0.19;
  for(let i=0;i<path.length;i++){
    let [r,c]=path[i];
    ctx.fillStyle="#ffd857";
    ctx.fillRect(c*GRID_SIZE,r*GRID_SIZE,GRID_SIZE,GRID_SIZE);
  }
  ctx.restore();
}

// --- ENEMIES ---
function spawnEnemy(){
  enemies.push({
    hp: ENEMY_HP+Math.floor(wave*3),
    maxHp: ENEMY_HP+Math.floor(wave*3),
    pathIdx:0,
    x:path[0][1]*GRID_SIZE+GRID_SIZE/2,
    y:path[0][0]*GRID_SIZE+GRID_SIZE/2,
    t:0
  });
}
let enemySpawnTimer = 0;
let enemiesToSpawn = Math.min(4+wave*2,24);

// --- TOWERS ---
function canPlaceTower(row,col){
  // Can't place on path or on another tower
  if(isOnPath(row,col)) return false;
  if(towers.some(t=>t.row===row&&t.col===col)) return false;
  return true;
}
canvas.addEventListener('click',e=>{
  if(!placingMode) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX-rect.left, my=e.clientY-rect.top;
  const col = Math.floor(mx/GRID_SIZE), row=Math.floor(my/GRID_SIZE);
  if(canPlaceTower(row,col)){
    let type = TOWER_TYPES[selectedTowerTypeIdx];
    if(gold>=type.cost){
      towers.push({
        ...type,
        row,col,
        x: col*GRID_SIZE+GRID_SIZE/2,
        y: row*GRID_SIZE+GRID_SIZE/2,
        cd:0 // cooldown timer
      });
      gold -= type.cost;
      updateUI();
      updateTowerButtons();
    }
  }
});

// --- GAME LOOP ---
function step(dt){
 // Spawn enemies
 if(enemiesToSpawn>0){
   enemySpawnTimer-=dt;
   if(enemySpawnTimer<=0){
     spawnEnemy();
     enemiesToSpawn--;
     enemySpawnTimer=800 - Math.min(400,wave*22);
   }
 }
 // Move enemies
 for(let en of enemies){
   let segA=path[en.pathIdx], segB=path[en.pathIdx+1];
   if(!segB) continue;
   let ax=segA[1]*GRID_SIZE+GRID_SIZE/2, ay=segA[0]*GRID_SIZE+GRID_SIZE/2;
   let bx=segB[1]*GRID_SIZE+GRID_SIZE/2, by=segB[0]*GRID_SIZE+GRID_SIZE/2;
   const dx=bx-ax, dy=by-ay;
   const len=Math.hypot(dx,dy);
   const speed=ENEMY_SPEED+wave*0.03;
   en.t += dt*speed/len;
   if(en.t>=1){
     en.pathIdx++;
     en.t=0;
     if(en.pathIdx>=path.length-1){
       lives--;
       en.hp=-1;
       updateUI();
     }
   }else{
     en.x=ax+dx*en.t; en.y=ay+dy*en.t;
   }
 }

 // Remove dead enemies
 enemies=enemies.filter(e=>e.hp>0);

 // Towers fire
 for(let tow of towers){
   tow.cd-=dt;
   if(tow.cd<=0){
     let target=null,minDist=9999;
     for(let en of enemies){
       let d=dist(tow.x,tow.y,en.x,en.y);
       if(d<=tow.range && d<minDist){ target=en; minDist=d;}
     }
     if(target){
       bullets.push({
         x:tow.x,y:tow.y,
         tx:target.x,ty:target.y,
         dx:(target.x-tow.x)/18,
         dy:(target.y-tow.y)/18,
         target,target,
         damage:tow.damage,
         color:tow.color
       });
       tow.cd=tow.cooldown;
     }
   }
 }

 // Bullets move
 for(let b of bullets){
   b.x+=b.dx; b.y+=b.dy;
 }
 // Collisions
 for(let b of bullets){
   if(b.target && dist(b.x,b.y,b.target.x,b.target.y)<13 && b.target.hp>0){
     b.target.hp-=b.damage;
     if(b.target.hp<=0){ gold+=ENEMY_REWARD+Math.floor(wave/2); updateUI(); updateTowerButtons();}
     b.hit=true;
   }
 }
 bullets=bullets.filter(b=>!b.hit && b.x>=0&&b.x<CANVAS_W&&b.y>=0&&b.y<CANVAS_H);

 // Win/loss/wave logic
 if(enemiesToSpawn<=0 && enemies.length==0){
   wave++; enemiesToSpawn=Math.min(4+wave*2,28); enemySpawnTimer=700-(wave*17);
 }

}

// --- RENDERING ---
function render(){
 ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
 drawPath();
 drawGrid();

 // Draw towers
 for(const t of towers){
   ctx.save();
   ctx.strokeStyle=t.color; ctx.globalAlpha=0.13;
   ctx.beginPath();ctx.arc(t.x,t.y,t.range,0,Math.PI*2);ctx.stroke();
   ctx.globalAlpha=1.0; ctx.fillStyle=t.color;
   ctx.beginPath();ctx.arc(t.x,t.y,t.radius||12,0,Math.PI*2);ctx.fill();
   ctx.restore();
 }
 // Draw enemies
 for(const en of enemies){
   ctx.save();
   ctx.strokeStyle="#111"; ctx.lineWidth=3;
   ctx.beginPath();ctx.arc(en.x,en.y,13,0,Math.PI*2);ctx.stroke();
   ctx.fillStyle="#e94e36";
   ctx.beginPath();ctx.arc(en.x,en.y,12,0,Math.PI*2);ctx.fill();

   // Health bar
   ctx.fillStyle="#222";
   ctx.fillRect(en.x-13,en.y-18,26,5);
   ctx.fillStyle="#5fc23c";
   const barW=Math.max(1,(en.hp/en.maxHp)*26);
   ctx.fillRect(en.x-13,en.y-18,barW,5);

   ctx.restore();
 }

 // Draw bullets
 for(const b of bullets){
   ctx.save();
   ctx.strokeStyle=b.color; ctx.lineWidth=3.5;
   ctx.beginPath();ctx.moveTo(b.x,b.y);ctx.lineTo(b.x-b.dx*4,b.y-b.dy*4);ctx.stroke();
   ctx.restore();
 }

 // Placement preview
 if(placingMode && canvas.matches(':hover')){
   canvas.style.cursor='crosshair';
   const mx=_lastMouse[0], my=_lastMouse[1];
   const col=Math.floor(mx/GRID_SIZE), row=Math.floor(my/GRID_SIZE);
   if(col>=0&&col<MAP_W&&row>=0&&row<MAP_H){
     let valid=canPlaceTower(row,col)&&TOWER_TYPES[selectedTowerTypeIdx].cost<=gold;
     let x=col*GRID_SIZE+GRID_SIZE/2,y=row*GRID_SIZE+GRID_SIZE/2;
     ctx.save();
     ctx.globalAlpha=.25; ctx.fillStyle=TOWER_TYPES[selectedTowerTypeIdx].color;
     ctx.beginPath();ctx.arc(x,y,TOWER_TYPES[selectedTowerTypeIdx].radius||12,0,Math.PI*2);ctx.fill();
     ctx.globalAlpha=.15;ctx.beginPath();ctx.arc(x,y,TOWER_TYPES[selectedTowerTypeIdx].range,0,Math.PI*2);ctx.fill();
     if(!valid){ctx.globalAlpha=.55;ctx.strokeStyle="#f44";ctx.setLineDash([4]);ctx.beginPath();ctx.arc(x,y,TOWER_TYPES[selectedTowerTypeIdx].radius||12,0,Math.PI*2);ctx.stroke();}
     ctx.restore();
   }
 } else canvas.style.cursor='default';

}

// Track mouse for placement preview
let _lastMouse=[-99,-99];
canvas.addEventListener('mousemove',e=>{
 const rect=canvas.getBoundingClientRect();
 _lastMouse=[e.clientX-rect.left,e.clientY-rect.top];
});

// --- MAIN LOOP ---
let lastTime=performance.now();
function loop(now){
 let dt=Math.min(60,(now-lastTime));
 step(dt);
 render();
 lastTime=now;
 requestAnimationFrame(loop);
}
updateUI();
loop(performance.now());

</script>
</body>
</html>