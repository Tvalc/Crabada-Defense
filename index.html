<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Crabada Defense</title>
  <style>
    /* Reset and Base Styles */
    :root {
        --text-light: #f0f4f8;
        --blue-dark: #1E3A47;
        --blue-mid: #2E86AB;
        --accent-orange: #F4A261;
        --accent-green: #2A9D8F;
        --accent-red: #E76F51;
    }

    html {
        font-size: 16px;
    }

    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
    }

    #game-container {
      position: relative;
      height: 100%;
      max-height: 95vh;
      aspect-ratio: 9 / 16;
      background: var(--blue-dark);
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }

    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    /* --- UI Overlays --- */
    
    #top-bar {
        position: absolute;
        top: 2%;
        left: 3%;
        right: 3%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 10;
    }
    
    #top-bar .back-btn, #top-bar .sound-btn {
        cursor: pointer;
        background: rgba(0,0,0,0.3);
        border-radius: 50%;
        width: 2.2rem;
        height: 2.2rem;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.2rem;
        color: var(--text-light);
        transition: transform 0.2s;
    }
    
    #top-bar .back-btn:hover, #top-bar .sound-btn:hover {
        transform: scale(1.1);
    }

    #towers-panel {
      position: absolute;
      top: 8%;
      left: 3%;
      background: rgba(0, 30, 40, 0.6);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 0.6rem;
      border-radius: 0.8rem;
      width: 25%;
      z-index: 5;
      box-sizing: border-box;
      border: 1px solid rgba(255,255,255,0.1);
    }

    #towers-panel h2 {
      margin: 0 0 0.5rem 0;
      color: var(--text-light);
      font-weight: 600;
      font-size: 0.9rem;
      text-align: center;
    }
    
    .towerButton {
      width: 100%;
      height: 2.8rem;
      margin-bottom: 0.5rem;
      background: var(--accent-orange);
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.2s;
      color: var(--text-light);
      font-weight: 600;
      font-size: 0.85rem;
      line-height: 1.1;
      text-align: center;
      padding: 0.2rem 0;
    }
    
    .towerButton small {
        font-size: 0.7em;
        font-weight: 500;
        opacity: 0.9;
    }

    .towerButton:hover { transform: scale(1.02); }
    .towerButton.selected { background: var(--accent-green); box-shadow: 0 0 10px var(--accent-green); }
    .towerButton.disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

    #start-wave-btn {
      width: 100%;
      padding: 0.5rem 0;
      background: var(--accent-green);
      color: var(--text-light);
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 600;
      margin-top: 0.2rem;
      transition: transform 0.2s;
    }
    
    #start-wave-btn:hover {
        transform: scale(1.02);
    }
    
    #info-panel {
        position: absolute;
        top: 8%;
        left: 30%;
        right: 3%;
        background: rgba(0, 30, 40, 0.6);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        padding: 0.6rem 0.8rem;
        border-radius: 0.8rem;
        color: var(--text-light);
        z-index: 5;
        box-sizing: border-box;
        border: 1px solid rgba(255,255,255,0.1);
    }
    
    #info-panel h1 {
        margin: 0 0 0.4rem 0;
        font-size: 1.2rem;
        text-align: center;
    }

    .info-stat {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 0;
        font-size: 0.9rem;
        line-height: 1.4;
    }
    
    #upgrade-panel {
      position: absolute;
      bottom: 2%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 30, 40, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 0.6rem 0.8rem;
      border-radius: 0.8rem;
      color: var(--text-light);
      z-index: 20;
      width: 80%;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.2);
      box-sizing: border-box;
    }

    #upgrade-panel h2 { margin: 0 0 0.4rem 0; font-size: 1rem; }
    
    .upgrade-stat { 
      margin: 0.2rem 0; 
      font-size: 0.85rem; 
      display: flex; 
      justify-content: space-between; 
      padding: 0 0.4rem;
    }
    .upgrade-stat span { opacity: 0.8; }

    #upgrade-btn, #sell-btn {
      box-sizing: border-box;
      width: 48%;
      display: inline-block;
      padding: 0.5rem 0;
      color: var(--text-light);
      border: none;
      border-radius: 0.6rem;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 600;
      margin-top: 0.4rem;
      transition: transform 0.2s;
    }
    #upgrade-btn { background: var(--accent-green); margin-right: 2%; }
    #sell-btn { background: var(--accent-red); margin-left: 2%; }
    #upgrade-btn:hover, #sell-btn:hover { transform: scale(1.02); }
    #upgrade-btn:disabled { background: #555; opacity: 0.7; cursor: not-allowed; transform: none; }

  </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="top-bar">
        <div class="back-btn" onclick="goBack()">&#x276E;</div>
        <div class="sound-btn" onclick="toggleSound()">&#x1F50A;</div>
    </div>
    
    <div id="towers-panel">
      <h2>Towers</h2>
      <button class="towerButton" id="basicTower" onclick="selectTower('basic')">
        Basic<br><small>100g</small>
      </button>
      <button class="towerButton" id="sniperTower" onclick="selectTower('sniper')">
        Sniper<br><small>200g</small>
      </button>
      <button class="towerButton" id="areaTower" onclick="selectTower('area')">
        Area<br><small>300g</small>
      </button>
      <button class="towerButton" id="slowTower" onclick="selectTower('slow')">
        Slow<br><small>150g</small>
      </button>
      <button id="start-wave-btn" onclick="startWave()">Start New Wave</button>
    </div>

    <div id="info-panel">
      <h1>Crabada Defense</h1>
      <div class="info-stat"><span>Wave:</span><b id="waveNum">0</b></div>
      <div class="info-stat"><span>Active Waves:</span><b id="activeWaves">0</b></div>
      <div class="info-stat"><span>Lives:</span><b id="lives">20</b></div>
      <div class="info-stat"><span>Gold:</span><b id="gold">500</b></div>
    </div>

    <div id="upgrade-panel" style="display: none;">
      <h2 id="upgrade-tower-name">Tower Name</h2>
      <div class="upgrade-stat"><span>Level:</span> <b id="upgrade-tower-level">1</b></div>
      <div class="upgrade-stat"><span>Damage:</span> <b id="upgrade-tower-damage">0</b></div>
      <div class="upgrade-stat"><span>Range:</span> <b id="upgrade-tower-range">0</b></div>
      <div class="upgrade-stat"><span>Speed:</span> <b id="upgrade-tower-speed">0</b></div>
      <div>
        <button id="upgrade-btn" onclick="upgradeSelectedTower()">Upgrade</button>
        <button id="sell-btn" onclick="sellSelectedTower()">Sell</button>
      </div>
    </div>
  </div>

  <script>
    // --- Game Constants & Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let W, H; // Canvas dimensions, set on resize

    const RELATIVE_ENEMY_PATH = [
      {x: 0.5, y: 0.95}, {x: 0.5, y: 0.85}, {x: 0.15, y: 0.85}, 
      {x: 0.15, y: 0.6}, {x: 0.85, y: 0.6}, {x: 0.85, y: 0.35},
      {x: 0.5, y: 0.35}, {x: 0.5, y: 0.05}
    ];

    const RELATIVE_TOWER_SPOTS = [
        // Top section - near enemy spawn
        {x: 0.25, y: 0.85}, {x: 0.75, y: 0.85}, {x: 0.45, y: 0.75},
        
        // Left side - covering the left turn
        {x: 0.08, y: 0.7}, {x: 0.08, y: 0.55}, {x: 0.22, y: 0.65},
        
        // Middle section - covering the horizontal path
        {x: 0.35, y: 0.55}, {x: 0.65, y: 0.55}, {x: 0.5, y: 0.45},
        
        // Right side - covering the right turn
        {x: 0.92, y: 0.5}, {x: 0.92, y: 0.35}, {x: 0.78, y: 0.45},
        
        // Bottom section - near enemy exit
        {x: 0.25, y: 0.25}, {x: 0.75, y: 0.25}, {x: 0.45, y: 0.15},
        
        // Additional strategic positions
        {x: 0.15, y: 0.45}, {x: 0.85, y: 0.65}, {x: 0.35, y: 0.35}, {x: 0.65, y: 0.35}
    ];
    
    let ENEMY_PATH = [];
    let TOWER_SPOTS = [];

    const TOWER_COSTS = { basic: 100, sniper: 200, area: 300, slow: 150 };
    const TOWER_STATS = {
      basic: { damage: 25, range: 0.15, attackSpeed: 1.0, projectileSpeed: 300 },
      sniper: { damage: 75, range: 0.3, attackSpeed: 0.5, projectileSpeed: 500 },
      area: { damage: 40, range: 0.12, attackSpeed: 0.8, projectileSpeed: 250, splash: 0.08 },
      slow: { damage: 15, range: 0.15, attackSpeed: 1.2, projectileSpeed: 350, slowEffect: 0.3 }
    };
    const ENEMY_STATS = {
      basic: { health: 100, speed: 40, reward: 10, size: 0.04 },
      fast: { health: 50, speed: 80, reward: 15, size: 0.03 },
      tank: { health: 300, speed: 20, reward: 25, size: 0.05 }
    };

    function rand(a, b) { return a + Math.random() * (b - a); }
    function distance(p1, p2) { return Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2); }

    let gameState = { 
      gold: 500, 
      lives: 20, 
      wave: 0, 
      activeWaves: [], // Array of active waves instead of single waveInProgress
      selection: null, 
      towers: [], 
      enemies: [], 
      projectiles: [], 
      particles: [], 
      time: 0 
    };

    // Load tower animation images
    const towerImages = {
      basic: []
    };
    
    // Preload tower animation frames
    function loadTowerImages() {
      const imageNames = ['BT1.png', 'BT2.png', 'BT3.png', 'BT4.png'];
      let loadedCount = 0;
      
      imageNames.forEach((name, index) => {
        const img = new Image();
        img.onload = () => {
          loadedCount++;
          if (loadedCount === imageNames.length) {
            console.log('All tower images loaded successfully!');
          }
        };
        img.src = name;
        towerImages.basic[index] = img;
      });
    }
    
    // Call image loading function
    loadTowerImages();

    // --- Core Game Classes ---
    class Tower {
      constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        this.baseStats = { ...TOWER_STATS[type] };
        this.stats = { ...TOWER_STATS[type] };
        this.lastAttack = 0; this.target = null; this.level = 1;
        this.totalCost = TOWER_COSTS[type];
        
        // Animation state
        this.animationFrame = 0;
        this.animationTime = 0;
        this.isFiring = false;
        this.fireAnimationDuration = 0.3; // seconds
      }

      getUpgradeCost() {
        if (this.level === 1) return Math.floor(TOWER_COSTS[this.type] * 1.5);
        if (this.level === 2) return Math.floor(TOWER_COSTS[this.type] * 3.0);
        return Infinity;
      }

      upgrade() {
        const cost = this.getUpgradeCost();
        if (this.level >= 3 || gameState.gold < cost) return;

        gameState.gold -= cost;
        this.level++;
        this.totalCost += cost;

        if (this.level === 2) {
            this.stats.damage = this.baseStats.damage * 1.5;
            this.stats.range = this.baseStats.range * 1.25;
        } else if (this.level === 3) {
            this.stats.damage = this.baseStats.damage * 2.0;
            this.stats.range = this.baseStats.range * 1.5;
            this.stats.attackSpeed = this.baseStats.attackSpeed * 1.25;
        }
        
        showUpgradePanel(this);
        updateUI();
      }
      
      sell() {
        const sellValue = Math.floor(this.totalCost * 0.7);
        gameState.gold += sellValue;
        
        const index = gameState.towers.indexOf(this);
        if (index > -1) gameState.towers.splice(index, 1);
        
        gameState.selection = null;
        hideUpgradePanel();
        updateUI();
      }

      update(dt) {
        this.lastAttack += dt;
        
        // Update animation for basic towers
        if (this.type === 'basic' && this.isFiring) {
          this.animationTime += dt;
          this.animationFrame = Math.floor((this.animationTime / this.fireAnimationDuration) * 4);
          
          if (this.animationTime >= this.fireAnimationDuration) {
            this.isFiring = false;
            this.animationFrame = 0;
          }
        }
        
        if (!this.target || this.target.health <= 0 || distance(this, this.target) > this.stats.range * W) {
            this.target = this.findTarget();
        }
        if (this.target && this.lastAttack >= 1/this.stats.attackSpeed) {
            this.attack();
            this.lastAttack = 0;
        }
      }

      findTarget() {
        let closest = null, minDist = this.stats.range * W;
        for (let enemy of gameState.enemies) {
          if (enemy.health <= 0) continue;
          let dist = distance(this, enemy);
          if (dist < minDist) { minDist = dist; closest = enemy; }
        }
        return closest;
      }

      attack() {
        if (!this.target) return;
        let angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
        gameState.projectiles.push(new Projectile(this, this.stats, this.target));
        spawnBubble(this.x, this.y);
        
        // Trigger firing animation for basic towers
        if (this.type === 'basic') {
          this.isFiring = true;
          this.animationTime = 0;
          this.animationFrame = 0;
        }
      }

      draw(time, ctx) {
        ctx.save();
        if (gameState.selection === this) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.stats.range * W, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();
        }

        // Draw different crab species based on tower type
        if (this.type === 'basic') {
          this.drawBlueCrab(time, ctx);
        } else if (this.type === 'sniper') {
          this.drawKingCrab(time, ctx);
        } else if (this.type === 'area') {
          this.drawHermitCrab(time, ctx);
        } else if (this.type === 'slow') {
          this.drawFiddlerCrab(time, ctx);
        }

        // Level indicator
        ctx.fillStyle = 'white';
        ctx.font = `bold ${W*0.035}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 3;
        ctx.strokeText(this.level, this.x, this.y + W * 0.08);
        ctx.fillText(this.level, this.x, this.y + W * 0.08);

        ctx.restore();
      }

      drawBlueCrab(time, ctx) {
        // Use loaded images for basic tower animation
        if (towerImages.basic.length > 0 && towerImages.basic[0].complete) {
          // Draw the appropriate animation frame
          const frameIndex = this.isFiring ? Math.min(this.animationFrame, 3) : 0;
          const img = towerImages.basic[frameIndex];
          
          if (img) {
            // Calculate image size and position
            const imgSize = W * 0.15; // Adjust size as needed
            const halfSize = imgSize / 2;
            
            // Draw the image centered on the tower position
            ctx.drawImage(img, 
              this.x - halfSize, 
              this.y - halfSize, 
              imgSize, 
              imgSize
            );
            
            // Add a glow effect when firing
            if (this.isFiring) {
              ctx.save();
              ctx.globalAlpha = 0.3;
              ctx.shadowColor = '#4682B4';
              ctx.shadowBlur = 15;
              ctx.drawImage(img, 
                this.x - halfSize, 
                this.y - halfSize, 
                imgSize, 
                imgSize
              );
              ctx.restore();
            }
          }
        } else {
          // Fallback to drawn crab if images aren't loaded yet
          const levelColors = ['#4682B4', '#5F9EA0', '#2F4F4F'];
          
          // Shell
          ctx.beginPath();
          ctx.arc(this.x, this.y, W * 0.06, 0, 2 * Math.PI);
          ctx.fillStyle = levelColors[this.level - 1];
          ctx.shadowColor = levelColors[this.level - 1];
          ctx.shadowBlur = 8;
          ctx.fill();
          ctx.shadowBlur = 0;
          
          // Shell pattern (blue crab has distinctive pattern)
          ctx.strokeStyle = '#2F4F4F';
          ctx.lineWidth = 1;
          // H pattern on shell
          ctx.beginPath();
          ctx.moveTo(this.x - W * 0.04, this.y - W * 0.04);
          ctx.lineTo(this.x + W * 0.04, this.y - W * 0.04);
          ctx.moveTo(this.x, this.y - W * 0.04);
          ctx.lineTo(this.x, this.y + W * 0.04);
          ctx.stroke();
          
          // Eyes
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.arc(this.x - W * 0.025, this.y - W * 0.05, W * 0.012, 0, 2 * Math.PI);
          ctx.arc(this.x + W * 0.025, this.y - W * 0.05, W * 0.012, 0, 2 * Math.PI);
          ctx.fill();
          
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(this.x - W * 0.025, this.y - W * 0.05, W * 0.006, 0, 2 * Math.PI);
          ctx.arc(this.x + W * 0.025, this.y - W * 0.05, W * 0.006, 0, 2 * Math.PI);
          ctx.fill();
          
          // Claws
          let clawAngle = Math.sin(time/400) * 0.4;
          ctx.save();
          ctx.translate(this.x - W * 0.08, this.y);
          ctx.rotate(-0.8 + clawAngle);
          ctx.fillStyle = '#4682B4';
          ctx.beginPath();
          ctx.ellipse(0, 0, W * 0.035, W * 0.02, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          ctx.save();
          ctx.translate(this.x + W * 0.08, this.y);
          ctx.rotate(0.8 - clawAngle);
          ctx.fillStyle = '#4682B4';
          ctx.beginPath();
          ctx.ellipse(0, 0, W * 0.035, W * 0.02, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          // Legs
          for (let i = 0; i < 4; i++) {
              let angle = (i / 3) * Math.PI * 0.6 - Math.PI * 0.3;
              ctx.strokeStyle = '#4682B4';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(this.x + Math.cos(angle) * W * 0.06, this.y + Math.sin(angle) * W * 0.06);
              ctx.lineTo(this.x + Math.cos(angle) * W * 0.09, this.y + Math.sin(angle) * W * 0.09);
              ctx.stroke();
          }
        }
      }

      drawKingCrab(time, ctx) {
        // King Crab - Sniper tower (larger, spikier)
        const levelColors = ['#8B0000', '#A0522D', '#654321'];
        
        // Large spiky shell
        ctx.beginPath();
        ctx.arc(this.x, this.y, W * 0.08, 0, 2 * Math.PI);
        ctx.fillStyle = levelColors[this.level - 1];
        ctx.shadowColor = levelColors[this.level - 1];
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Spikes on shell
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
            let angle = (i / 7) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(this.x + Math.cos(angle) * W * 0.08, this.y + Math.sin(angle) * W * 0.08);
            ctx.lineTo(this.x + Math.cos(angle) * W * 0.12, this.y + Math.sin(angle) * W * 0.12);
            ctx.stroke();
        }
        
        // Large eyes
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(this.x - W * 0.03, this.y - W * 0.06, W * 0.015, 0, 2 * Math.PI);
        ctx.arc(this.x + W * 0.03, this.y - W * 0.06, W * 0.015, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(this.x - W * 0.03, this.y - W * 0.06, W * 0.008, 0, 2 * Math.PI);
        ctx.arc(this.x + W * 0.03, this.y - W * 0.06, W * 0.008, 0, 2 * Math.PI);
        ctx.fill();
        
        // Massive claws
        let clawAngle = Math.sin(time/500) * 0.3;
        ctx.save();
        ctx.translate(this.x - W * 0.12, this.y);
        ctx.rotate(-0.9 + clawAngle);
        ctx.fillStyle = '#8B0000';
        ctx.beginPath();
        ctx.ellipse(0, 0, W * 0.05, W * 0.025, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        ctx.save();
        ctx.translate(this.x + W * 0.12, this.y);
        ctx.rotate(0.9 - clawAngle);
        ctx.fillStyle = '#8B0000';
        ctx.beginPath();
        ctx.ellipse(0, 0, W * 0.05, W * 0.025, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Long legs
        for (let i = 0; i < 6; i++) {
            let angle = (i / 5) * Math.PI * 0.8 - Math.PI * 0.4;
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x + Math.cos(angle) * W * 0.08, this.y + Math.sin(angle) * W * 0.08);
            ctx.lineTo(this.x + Math.cos(angle) * W * 0.15, this.y + Math.sin(angle) * W * 0.15);
            ctx.stroke();
        }
      }

      drawHermitCrab(time, ctx) {
        // Hermit Crab - Area tower (lives in shell)
        const levelColors = ['#DEB887', '#D2B48C', '#BC8F8F'];
        
        // Spiral shell
        ctx.fillStyle = levelColors[this.level - 1];
        ctx.beginPath();
        ctx.arc(this.x, this.y, W * 0.07, 0, 2 * Math.PI);
        ctx.fill();
        
        // Shell spiral pattern
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, W * (0.07 - i * 0.02), 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Hermit crab body (smaller, peeking out)
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.arc(this.x, this.y - W * 0.02, W * 0.04, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes on stalks
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(this.x - W * 0.02, this.y - W * 0.06, W * 0.01, 0, 2 * Math.PI);
        ctx.arc(this.x + W * 0.02, this.y - W * 0.06, W * 0.01, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(this.x - W * 0.02, this.y - W * 0.06, W * 0.005, 0, 2 * Math.PI);
        ctx.arc(this.x + W * 0.02, this.y - W * 0.06, W * 0.005, 0, 2 * Math.PI);
        ctx.fill();
        
        // Eye stalks
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x - W * 0.02, this.y - W * 0.04);
        ctx.lineTo(this.x - W * 0.02, this.y - W * 0.06);
        ctx.moveTo(this.x + W * 0.02, this.y - W * 0.04);
        ctx.lineTo(this.x + W * 0.02, this.y - W * 0.06);
        ctx.stroke();
        
        // Small claws
        let clawAngle = Math.sin(time/300) * 0.5;
        ctx.save();
        ctx.translate(this.x - W * 0.06, this.y);
        ctx.rotate(-0.6 + clawAngle);
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.ellipse(0, 0, W * 0.025, W * 0.015, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        ctx.save();
        ctx.translate(this.x + W * 0.06, this.y);
        ctx.rotate(0.6 - clawAngle);
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.ellipse(0, 0, W * 0.025, W * 0.015, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Small legs
        for (let i = 0; i < 4; i++) {
            let angle = (i / 3) * Math.PI * 0.5 - Math.PI * 0.25;
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(this.x + Math.cos(angle) * W * 0.07, this.y + Math.sin(angle) * W * 0.07);
            ctx.lineTo(this.x + Math.cos(angle) * W * 0.1, this.y + Math.sin(angle) * W * 0.1);
            ctx.stroke();
        }
      }

      drawFiddlerCrab(time, ctx) {
        // Fiddler Crab - Slow tower (one large claw, one small)
        const levelColors = ['#FF6347', '#DC143C', '#8B0000'];
        
        // Body
        ctx.beginPath();
        ctx.arc(this.x, this.y, W * 0.05, 0, 2 * Math.PI);
        ctx.fillStyle = levelColors[this.level - 1];
        ctx.shadowColor = levelColors[this.level - 1];
        ctx.shadowBlur = 6;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Eyes
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(this.x - W * 0.02, this.y - W * 0.04, W * 0.01, 0, 2 * Math.PI);
        ctx.arc(this.x + W * 0.02, this.y - W * 0.04, W * 0.01, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(this.x - W * 0.02, this.y - W * 0.04, W * 0.005, 0, 2 * Math.PI);
        ctx.arc(this.x + W * 0.02, this.y - W * 0.04, W * 0.005, 0, 2 * Math.PI);
        ctx.fill();
        
        // Large claw (fiddler crab signature)
        let clawAngle = Math.sin(time/600) * 0.6;
        ctx.save();
        ctx.translate(this.x - W * 0.1, this.y);
        ctx.rotate(-0.5 + clawAngle);
        ctx.fillStyle = '#FF6347';
        ctx.beginPath();
        ctx.ellipse(0, 0, W * 0.06, W * 0.03, 0, 0, Math.PI * 2);
        ctx.fill();
        // Claw details
        ctx.strokeStyle = '#8B0000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, W * 0.06, W * 0.03, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // Small claw
        ctx.save();
        ctx.translate(this.x + W * 0.06, this.y);
        ctx.rotate(0.3);
        ctx.fillStyle = '#FF6347';
        ctx.beginPath();
        ctx.ellipse(0, 0, W * 0.025, W * 0.015, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Legs
        for (let i = 0; i < 4; i++) {
            let angle = (i / 3) * Math.PI * 0.6 - Math.PI * 0.3;
            ctx.strokeStyle = '#FF6347';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(this.x + Math.cos(angle) * W * 0.05, this.y + Math.sin(angle) * W * 0.05);
            ctx.lineTo(this.x + Math.cos(angle) * W * 0.08, this.y + Math.sin(angle) * W * 0.08);
            ctx.stroke();
        }
      }
    }

    class Enemy {
      constructor(config) {
        if (ENEMY_PATH.length === 0) {
          console.error("ENEMY_PATH not initialized!");
          return;
        }
        this.x = ENEMY_PATH[0].x;
        this.y = ENEMY_PATH[0].y;
        console.log("Enemy created at:", this.x, this.y, "Canvas size:", W, "x", H);
        this.pathIndex = 1;
        this.health = config.health;
        this.maxHealth = config.health;
        this.speed = config.speed;
        this.radius = 10;
        this.type = config.type;
        this.color = this.type === 'brute' ? '#E76F51' : '#F4A261';
        this.goldReward = this.type === 'brute' ? 15 : 8; // Gold reward for killing
      }

      update(deltaTime) {
        if (this.pathIndex >= ENEMY_PATH.length) return;

        const targetX = ENEMY_PATH[this.pathIndex].x;
        const targetY = ENEMY_PATH[this.pathIndex].y;
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 1) {
            this.pathIndex++;
            if (this.pathIndex >= ENEMY_PATH.length) {
                gameState.lives--;
                updateUI();
                this.health = 0; // Mark for removal
            }
        } else {
            const moveX = (dx / dist) * this.speed * deltaTime;
            const moveY = (dy / dist) * this.speed * deltaTime;
            this.x += moveX;
            this.y += moveY;
            
            // Debug logging for first enemy
            if (this === gameState.enemies[0]) {
                console.log(`Enemy moving: x=${this.x.toFixed(1)}, y=${this.y.toFixed(1)}, target=${targetX.toFixed(1)},${targetY.toFixed(1)}, speed=${this.speed}, dt=${deltaTime.toFixed(3)}`);
            }
        }
      }
      
      draw(time, ctx) {
        ctx.save();
        
        // Determine animal type based on enemy type
        const animalType = this.type === 'brute' ? 'bear' : 'penguin';
        
        if (animalType === 'penguin') {
          // Draw cute penguin
          // Body (oval)
          ctx.fillStyle = '#2C3E50';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y, this.radius * 0.8, this.radius * 1.2, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Belly (white oval)
          ctx.fillStyle = '#ECF0F1';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y + this.radius * 0.2, this.radius * 0.5, this.radius * 0.8, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Head
          ctx.fillStyle = '#2C3E50';
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.radius * 0.8, this.radius * 0.6, 0, Math.PI * 2);
          ctx.fill();
          
          // Eyes
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.arc(this.x - this.radius * 0.2, this.y - this.radius * 0.9, this.radius * 0.15, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(this.x + this.radius * 0.2, this.y - this.radius * 0.9, this.radius * 0.15, 0, Math.PI * 2);
          ctx.fill();
          
          // Pupils
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(this.x - this.radius * 0.2, this.y - this.radius * 0.9, this.radius * 0.08, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(this.x + this.radius * 0.2, this.y - this.radius * 0.9, this.radius * 0.08, 0, Math.PI * 2);
          ctx.fill();
          
          // Beak
          ctx.fillStyle = '#F39C12';
          ctx.beginPath();
          ctx.moveTo(this.x, this.y - this.radius * 0.6);
          ctx.lineTo(this.x - this.radius * 0.1, this.y - this.radius * 0.4);
          ctx.lineTo(this.x + this.radius * 0.1, this.y - this.radius * 0.4);
          ctx.closePath();
          ctx.fill();
          
          // Wings
          ctx.fillStyle = '#34495E';
          ctx.beginPath();
          ctx.ellipse(this.x - this.radius * 0.8, this.y, this.radius * 0.3, this.radius * 0.6, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(this.x + this.radius * 0.8, this.y, this.radius * 0.3, this.radius * 0.6, 0, 0, Math.PI * 2);
          ctx.fill();
          
        } else if (animalType === 'bear') {
          // Draw cute bear with water helmet
          // Water helmet (bubble)
          ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';
          ctx.strokeStyle = '#87CEEB';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.radius * 1.4, this.radius * 0.9, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Helmet strap
          ctx.strokeStyle = '#4682B4';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.radius * 1.4, this.radius * 0.9, Math.PI * 0.3, Math.PI * 0.7);
          ctx.stroke();
          
          // Body
          ctx.fillStyle = '#8B4513';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Head
          ctx.fillStyle = '#8B4513';
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.radius * 0.7, this.radius * 0.8, 0, Math.PI * 2);
          ctx.fill();
          
          // Ears
          ctx.fillStyle = '#654321';
          ctx.beginPath();
          ctx.arc(this.x - this.radius * 0.4, this.y - this.radius * 1.2, this.radius * 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(this.x + this.radius * 0.4, this.y - this.radius * 1.2, this.radius * 0.3, 0, Math.PI * 2);
          ctx.fill();
          
          // Eyes
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.arc(this.x - this.radius * 0.25, this.y - this.radius * 0.8, this.radius * 0.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(this.x + this.radius * 0.25, this.y - this.radius * 0.8, this.radius * 0.2, 0, Math.PI * 2);
          ctx.fill();
          
          // Pupils
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(this.x - this.radius * 0.25, this.y - this.radius * 0.8, this.radius * 0.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(this.x + this.radius * 0.25, this.y - this.radius * 0.8, this.radius * 0.1, 0, Math.PI * 2);
          ctx.fill();
          
          // Nose
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(this.x, this.y - this.radius * 0.6, this.radius * 0.08, 0, Math.PI * 2);
          ctx.fill();
          
          // Belly patch
          ctx.fillStyle = '#DEB887';
          ctx.beginPath();
          ctx.arc(this.x, this.y + this.radius * 0.3, this.radius * 0.6, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Health bar
        if (this.health < this.maxHealth) {
            ctx.fillStyle = 'red';
            ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, this.radius * 2, 4);
            ctx.fillStyle = 'green';
            ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, (this.radius * 2) * (this.health / this.maxHealth), 4);
        }
        
        ctx.restore();
      }
      
      takeDamage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
            // Award gold when enemy is killed
            gameState.gold += this.goldReward;
            updateUI();
            this.health = 0; // Mark for removal
        }
      }
    }

    class Projectile {
      constructor(tower, stats, target) {
        this.x = tower.x;
        this.y = tower.y;
        this.damage = stats.damage;
        this.type = tower.type;
        this.target = target;
        this.splash = stats.splash || 0;
        this.active = true;
        let angle = Math.atan2(target.y - tower.y, target.x - tower.x);
        this.vx = Math.cos(angle) * stats.projectileSpeed;
        this.vy = Math.sin(angle) * stats.projectileSpeed;
      }
      update(dt) {
        if (!this.active) return;
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        if (this.target.health > 0 && distance(this, this.target) < 20) {
            this.hit();
            return;
        }
        if (this.x < 0 || this.x > W || this.y < 0 || this.y > H) {
            this.active = false;
        }
      }
      hit() {
        if (this.target.health <= 0) return;
        this.active = false;
        this.target.takeDamage(this.damage);
        if (this.type === 'slow') {
            this.target.slowEffect = 0.3;
            this.target.slowTimer = 3.0;
        }
        if (this.type === 'area' && this.splash > 0) {
            for (let enemy of gameState.enemies) {
                if (enemy.health > 0 && enemy !== this.target && distance(this.target, enemy) < this.splash * W) {
                    enemy.takeDamage(this.damage * 0.5);
                }
            }
        }
        spawnBubble(this.x, this.y);
      }
      draw(time, ctx) {
        if (!this.active) return;
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, W * 0.01, 0, 2 * Math.PI);
        ctx.fillStyle = this.type === 'slow' ? '#2A9D8F' : '#F4A261';
        ctx.fill();
        ctx.restore();
      }
    }

    class Particle {
      constructor(x,y,vx,vy,r,life) {
          this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=r; this.life=life; this.maxLife=life;
      }
      update(dt) {
          this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt;
      }
      draw(time, ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
      }
    }
    
    // --- Drawing & Rendering ---

    function spawnBubble(x, y, count = 3) {
      for (let i = 0; i < count; i++) {
          gameState.particles.push(new Particle(x+rand(-5,5), y+rand(-5,5), rand(-20,20), rand(-50,-150), rand(2,5), rand(0.7,1.2)));
      }
    }

    function drawBackground(time) {
      ctx.save();
      ctx.fillStyle = '#2E86AB';
      ctx.fillRect(0, 0, W, H);
      for (let i = 0; i < 5; i++) {
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#1E3A47';
        ctx.beginPath();
        ctx.moveTo(i * W/4, H);
        for (let x = i * W/4; x < (i+1) * W/4; x += 20) {
            ctx.lineTo(x, H - H*0.05 - H*0.03 * Math.sin((x/60) + time/2000 + i));
        }
        ctx.lineTo((i+1)*W/4, H);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      for (let i = 0; i < 12; i++) {
        ctx.save();
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = '#2A9D8F';
        ctx.lineWidth = 6;
        ctx.beginPath();
        let baseX = W*0.1 + i * W*0.07;
        ctx.moveTo(baseX, H);
        for (let y = H; y > H-H*0.2; y -= 10) {
            ctx.lineTo(baseX + 10 * Math.sin(time/800 + i + y/30), y);
        }
        ctx.stroke();
        ctx.restore();
      }
      for (let i = 0; i < 30; i++) {
        let bx = (i * W/15 + (time/30) % W) % W;
        let by = H - ((time/20 + i*100) % H);
        ctx.save();
        ctx.globalAlpha = 0.15 + 0.1 * Math.sin(time/500 + i);
        ctx.beginPath();
        ctx.arc(bx, by, W*0.02 + W*0.01 * Math.sin(time/700 + i), 0, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();
    }

    function drawPath() {
      if (ENEMY_PATH.length < 2) return;
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = W * 0.1;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(ENEMY_PATH[0].x, ENEMY_PATH[0].y);
      for (let i = 1; i < ENEMY_PATH.length; i++) {
          ctx.lineTo(ENEMY_PATH[i].x, ENEMY_PATH[i].y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawTowerSpots() {
      ctx.save();
      for (let spot of TOWER_SPOTS) {
        let occupied = gameState.towers.some(tower => tower.x === spot.x && tower.y === spot.y);
        ctx.beginPath();
        ctx.arc(spot.x, spot.y, W*0.05, 0, 2 * Math.PI);
        
        if (typeof gameState.selection === 'string' && !occupied) {
            ctx.fillStyle = 'rgba(42, 157, 143, 0.5)';
            ctx.fill();
        }
        
        ctx.strokeStyle = occupied ? 'rgba(255,0,0,0.5)' : 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      ctx.restore();
    }

    // --- Game Logic & State Management ---

    function getPathPosition(progress) {
      if (ENEMY_PATH.length === 0) return { x: -1, y: -1};
      let totalLength = 0;
      for (let i = 1; i < ENEMY_PATH.length; i++) {
          totalLength += distance(ENEMY_PATH[i-1], ENEMY_PATH[i]);
      }
      
      let targetDistance = progress * totalLength;
      let currentDistance = 0;
      
      for (let i = 1; i < ENEMY_PATH.length; i++) {
        let p1 = ENEMY_PATH[i-1];
        let p2 = ENEMY_PATH[i];
        let segmentLength = distance(p1, p2);
        if (currentDistance + segmentLength >= targetDistance) {
          let segmentProgress = (targetDistance - currentDistance) / segmentLength;
          return {
            x: p1.x + (p2.x - p1.x) * segmentProgress,
            y: p1.y + (p2.y - p1.y) * segmentProgress
          };
        }
        currentDistance += segmentLength;
      }
      return ENEMY_PATH[ENEMY_PATH.length - 1];
    }
    
    function selectTower(type) { 
      if (gameState.selection === type) {
          gameState.selection = null;
      } else if (gameState.gold >= TOWER_COSTS[type]) { 
          gameState.selection = type;
          hideUpgradePanel();
      }
      updateTowerButtons();
    }

    function startWave() {
      console.log("startWave called");
      
      // Create a new wave
      let newWave = {
        waveNumber: gameState.wave + 1,
        enemies: [],
        lastSpawn: gameState.time,
        spawnInterval: 1000,
        isActive: true
      };
      
      gameState.wave++;
      console.log("Starting wave", gameState.wave);
      
      // Generate enemies for this wave
      let enemyCount = 10 + gameState.wave * 2;
      console.log("Creating", enemyCount, "enemies for wave", gameState.wave);
      
      for (let i = 0; i < enemyCount; i++) {
        let type = 'minion';
        if (gameState.wave >= 2 && Math.random() < 0.3) type = 'brute';
        if (gameState.wave >= 3 && Math.random() < 0.2) type = 'brute';
        
        // Create enemy config based on type
        let config = {
          type: type,
          health: type === 'brute' ? 150 : 50,
          speed: type === 'brute' ? 15 : 20
        };
        
        newWave.enemies.push(config);
      }
      
      // Add the new wave to active waves
      gameState.activeWaves.push(newWave);
      console.log("Wave enemies created:", newWave.enemies.length);
      console.log("Total active waves:", gameState.activeWaves.length);
      
      updateUI();
    }
    
    function findTowerAt(x, y) {
      for (const tower of gameState.towers) {
          if (distance({x,y}, tower) < W * 0.06) return tower;
      }
      return null;
    }

    function findClosestTowerSpot(x, y) {
      let closest = null, minDist = W*0.1;
      for (let spot of TOWER_SPOTS) {
        let dist = distance({x,y}, spot);
        let occupied = gameState.towers.some(tower => tower.x === spot.x && tower.y === spot.y);
        if (!occupied && dist < minDist) {
            minDist = dist;
            closest = spot;
        }
      }
      return closest;
    }

    // --- UI Management ---
    function updateUI() {
      document.getElementById('gold').textContent = gameState.gold;
      document.getElementById('lives').textContent = gameState.lives;
      document.getElementById('waveNum').textContent = gameState.wave;
      document.getElementById('activeWaves').textContent = gameState.activeWaves.length;
      updateTowerButtons();
    }

    function updateTowerButtons() {
      for (let type in TOWER_COSTS) {
        let btn = document.getElementById(type + 'Tower');
        if(!btn) continue;
        btn.classList.remove('selected', 'disabled');
        if (typeof gameState.selection === 'string' && gameState.selection === type) {
          btn.classList.add('selected');
        }
        if (gameState.gold < TOWER_COSTS[type]) {
          btn.classList.add('disabled');
        }
      }
      document.getElementById('start-wave-btn').disabled = false; // Allow multiple waves
    }
    
    function showUpgradePanel(tower) {
        const panel = document.getElementById('upgrade-panel');
        if (!tower) { panel.style.display = 'none'; return; }

        document.getElementById('upgrade-tower-name').textContent = `${tower.type.charAt(0).toUpperCase() + tower.type.slice(1)} Tower`;
        document.getElementById('upgrade-tower-level').textContent = tower.level;
        document.getElementById('upgrade-tower-damage').textContent = tower.stats.damage.toFixed(0);
        document.getElementById('upgrade-tower-range').textContent = (tower.stats.range * W).toFixed(0);
        document.getElementById('upgrade-tower-speed').textContent = tower.stats.attackSpeed.toFixed(2);

        const upgradeBtn = document.getElementById('upgrade-btn');
        const upgradeCost = tower.getUpgradeCost();
        if (tower.level >= 3) {
            upgradeBtn.disabled = true;
            upgradeBtn.textContent = 'Max Level';
        } else {
            upgradeBtn.disabled = gameState.gold < upgradeCost;
            upgradeBtn.textContent = `Upgrade (${upgradeCost}g)`;
        }
        
        const sellBtn = document.getElementById('sell-btn');
        sellBtn.textContent = `Sell (${Math.floor(tower.totalCost * 0.7)}g)`;
        
        panel.style.display = 'block';
    }

    function hideUpgradePanel() {
        document.getElementById('upgrade-panel').style.display = 'none';
    }

    function upgradeSelectedTower() {
        if (gameState.selection && typeof gameState.selection === 'object') {
            gameState.selection.upgrade();
        }
    }
    
    function sellSelectedTower() {
        if (gameState.selection && typeof gameState.selection === 'object') {
            gameState.selection.sell();
        }
    }
    
    function goBack() { alert("Back button clicked!"); }
    function toggleSound() { alert("Sound toggled!"); }
    
    // --- Main Game Loop & Initialization ---

    let lastTime = 0;
    function gameLoop(time) {
      let dt = Math.min(0.05, (time - lastTime) / 1000) || 0;
      lastTime = time;
      gameState.time = time;

      // Update logic
      [gameState.towers, gameState.enemies, gameState.projectiles, gameState.particles].forEach(arr => {
          arr.forEach(o => o.update(dt));
      });
      
      gameState.enemies = gameState.enemies.filter(e => e.health > 0);
      gameState.projectiles = gameState.projectiles.filter(p => p.active);
      gameState.particles = gameState.particles.filter(p => p.life > 0);

      // Update wave spawning for all active waves
      for (let i = gameState.activeWaves.length - 1; i >= 0; i--) {
        let wave = gameState.activeWaves[i];
        
        if (wave.enemies.length > 0) {
          // Spawn enemies from this wave
          if (time - wave.lastSpawn > wave.spawnInterval) {
            console.log("Spawning enemy from wave", wave.waveNumber, "remaining:", wave.enemies.length);
            let newEnemy = new Enemy(wave.enemies.shift());
            gameState.enemies.push(newEnemy);
            wave.lastSpawn = time;
          }
        } else if (wave.enemies.length === 0 && gameState.enemies.length === 0) {
          // Wave is complete (no more enemies to spawn and no enemies on map)
          console.log("Wave", wave.waveNumber, "completed");
          gameState.activeWaves.splice(i, 1);
          updateUI();
        }
      }

      // Drawing logic
      ctx.clearRect(0, 0, W, H);
      drawBackground(time);
      drawPath();
      drawTowerSpots();
      
      [gameState.towers, gameState.enemies, gameState.projectiles, gameState.particles].forEach(arr => {
          arr.forEach(o => o.draw(time, ctx));
      });
      
      // Check for game over
      if (gameState.lives <= 0) {
        alert('Game Over! You survived ' + (gameState.wave) + ' waves!');
        window.location.reload();
      }
      
      requestAnimationFrame(gameLoop);
    }

    function resizeCanvas() {
      const container = document.getElementById('game-container');
      const { width, height } = container.getBoundingClientRect();
      
      // Set canvas to container dimensions
      W = canvas.width = width;
      H = canvas.height = height;
      
      console.log("Canvas resized to:", W, "x", H);
      
      // Update path coordinates
      ENEMY_PATH = RELATIVE_ENEMY_PATH.map(p => ({ x: p.x * W, y: p.y * H }));
      TOWER_SPOTS = RELATIVE_TOWER_SPOTS.map(p => ({ x: p.x * W, y: p.y * H }));
      
      console.log("ENEMY_PATH[0]:", ENEMY_PATH[0]);
    }

    canvas.addEventListener('click', e => {
      let rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;

      let clickedTower = findTowerAt(x, y);

      if (clickedTower) {
          gameState.selection = clickedTower;
          showUpgradePanel(clickedTower);
      } else {
          if (typeof gameState.selection === 'string') {
              let spot = findClosestTowerSpot(x, y);
              if (spot) {
                  const cost = TOWER_COSTS[gameState.selection];
                  if(gameState.gold >= cost){
                    gameState.towers.push(new Tower(spot.x, spot.y, gameState.selection));
                    gameState.gold -= cost;
                    gameState.selection = null;
                    updateUI();
                  }
              }
          } else {
              gameState.selection = null;
              hideUpgradePanel();
          }
      }
    });

    function initializeGame() {
        const container = document.getElementById('game-container');
        if (container.clientWidth > 0 && container.clientHeight > 0) {
            resizeCanvas();
            updateUI();
            requestAnimationFrame(gameLoop);
        } else {
            // Poll until the container has dimensions
            setTimeout(initializeGame, 50);
        }
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', initializeGame);
  </script>
</body>
</html>
