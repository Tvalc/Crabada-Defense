<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Crabada Defense - Visual Demo</title>
  <style>
    html, body { margin: 0; padding: 0; background: #264653; overflow: hidden; }
    #gameCanvas { display: block; margin: 0 auto; background: #1E3A47; }
    #ui {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      color: #fff; font-family: 'Orbitron', Arial, sans-serif; text-align: center;
      background: rgba(46,134,171,0.7); padding: 12px 32px; border-radius: 16px;
      box-shadow: 0 4px 24px #0008;
      animation: float 3s ease-in-out infinite alternate;
    }
    @keyframes float {
      0% { transform: translateX(-50%) translateY(0); }
      100% { transform: translateX(-50%) translateY(10px); }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="900" height="600"></canvas>
  <div id="ui">
    <h1>Crabada Defense</h1>
    <span>Wave: <b id="waveNum">1</b> &nbsp; | &nbsp; Gold: <b id="gold">500</b></span>
  </div>
  <script>
    // --- Parallax Background Layers ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // Helper: random float
    function rand(a, b) { return a + Math.random() * (b - a); }

    // Parallax background: 3 layers of procedural seaweed/coral
    function drawBackground(time) {
      ctx.save();
      // Distant water
      ctx.fillStyle = '#2E86AB';
      ctx.fillRect(0, 0, W, H);

      // Layer 1: distant reefs
      for (let i = 0; i < 5; i++) {
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#1E3A47';
        ctx.beginPath();
        ctx.moveTo(i * 200, H);
        for (let x = i * 200; x < (i+1) * 200; x += 20) {
          ctx.lineTo(x, H - 40 - 20 * Math.sin((x/60) + time/2000 + i));
        }
        ctx.lineTo((i+1)*200, H);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      // Layer 2: swaying seaweed
      for (let i = 0; i < 12; i++) {
        ctx.save();
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = '#2A9D8F';
        ctx.lineWidth = 6;
        ctx.beginPath();
        let baseX = 60 + i * 70;
        ctx.moveTo(baseX, H);
        for (let y = H; y > H-120; y -= 10) {
          let sway = 10 * Math.sin(time/800 + i + y/30);
          ctx.lineTo(baseX + sway, y);
        }
        ctx.stroke();
        ctx.restore();
      }

      // Layer 3: bubbles
      for (let i = 0; i < 30; i++) {
        let bx = (i * 30 + (time/3) % W) % W;
        let by = H - ((time/2 + i*100) % H);
        ctx.save();
        ctx.globalAlpha = 0.15 + 0.1 * Math.sin(time/500 + i);
        ctx.beginPath();
        ctx.arc(bx, by, 8 + 4 * Math.sin(time/700 + i), 0, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();
    }

    // --- Towers (Procedural Crustacean Turrets) ---
    function drawTower(x, y, time) {
      ctx.save();
      // Body
      ctx.beginPath();
      ctx.arc(x, y, 28, 0, 2 * Math.PI);
      ctx.fillStyle = '#F4A261';
      ctx.shadowColor = '#E76F51';
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.shadowBlur = 0;
      // Eyes
      ctx.beginPath();
      ctx.arc(x-10, y-18, 6, 0, 2 * Math.PI);
      ctx.arc(x+10, y-18, 6, 0, 2 * Math.PI);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x-10, y-18, 2, 0, 2 * Math.PI);
      ctx.arc(x+10, y-18, 2, 0, 2 * Math.PI);
      ctx.fillStyle = '#222';
      ctx.fill();
      // Claws (animated)
      let clawAngle = Math.sin(time/300) * 0.3;
      ctx.save();
      ctx.translate(x-24, y-8);
      ctx.rotate(-0.7 + clawAngle);
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI, true);
      ctx.lineTo(-8, 8);
      ctx.closePath();
      ctx.fillStyle = '#E76F51';
      ctx.fill();
      ctx.restore();
      ctx.save();
      ctx.translate(x+24, y-8);
      ctx.rotate(0.7 - clawAngle);
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI, false);
      ctx.lineTo(8, 8);
      ctx.closePath();
      ctx.fillStyle = '#E76F51';
      ctx.fill();
      ctx.restore();
      ctx.restore();
    }

    // --- Enemies (Procedural Jellyfish) ---
    function drawEnemy(x, y, time) {
      ctx.save();
      // Body
      ctx.beginPath();
      ctx.ellipse(x, y, 20, 16, 0, 0, 2 * Math.PI);
      ctx.fillStyle = '#2E86AB';
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;
      // Tentacles (animated)
      for (let i = -2; i <= 2; i++) {
        ctx.beginPath();
        ctx.moveTo(x + i*7, y+10);
        for (let j = 0; j < 6; j++) {
          let dx = Math.sin(time/200 + i*2 + j) * 2;
          ctx.lineTo(x + i*7 + dx, y+10 + j*6);
        }
        ctx.strokeStyle = '#B8C5CC';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();
    }

    // --- Particle Effects (Bubbles) ---
    class Particle {
      constructor(x, y, vx, vy, r, life) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.r = r; this.life = life; this.maxLife = life;
      }
      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
      }
      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
      }
    }
    let particles = [];
    function spawnBubble(x, y) {
      for (let i = 0; i < 3; i++) {
        particles.push(new Particle(
          x + rand(-5,5), y + rand(-5,5),
          rand(-0.1,0.1), rand(-0.5,-1.5),
          rand(2,5), rand(0.7,1.2)
        ));
      }
    }

    // --- Game State ---
    let towers = [{x: 200, y: 400}, {x: 700, y: 350}];
    let enemies = [{x: 0, y: 200, t: 0}];
    let gold = 500, wave = 1, lastSpawn = 0;

    // --- Main Loop ---
    let lastTime = 0;
    function gameLoop(time) {
      let dt = (time - lastTime) / 1000;
      lastTime = time;
      ctx.clearRect(0, 0, W, H);

      // Draw background
      drawBackground(time);

      // Draw towers
      for (let t of towers) drawTower(t.x, t.y, time);

      // Move and draw enemies
      for (let e of enemies) {
        e.x += 60 * dt; // move right
        e.t += dt;
        drawEnemy(e.x, e.y + Math.sin(e.t*2)*8, time);
        if (Math.random() < 0.1) spawnBubble(e.x, e.y+10);
      }
      // Remove enemies off screen
      enemies = enemies.filter(e => e.x < W+40);

      // Draw and update particles
      for (let p of particles) p.update(dt);
      particles = particles.filter(p => p.life > 0);
      for (let p of particles) p.draw(ctx);

      // UI updates
      document.getElementById('gold').textContent = gold;
      document.getElementById('waveNum').textContent = wave;

      // Spawn new enemies
      if (time - lastSpawn > 2000) {
        enemies.push({x: 0, y: rand(150, 500), t: 0});
        lastSpawn = time;
      }

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html> 